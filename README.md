### 🛡️ 장애 복구 및 멱등성 보장 메커니즘 (Exactly-Once 논리)

| 매커니즘 | 관련 시스템/설정 | 역할 및 동작 방식 | 상호작용을 통한 멱등성 보장 원리 |
| :--- | :--- | :--- | :--- |
| **순서 보장** | **Kafka Producer Key (`deviceId`)** | Producer는 **`deviceId`를 메시지 Key**로 사용합니다. 동일 장비의 이벤트는 항상 같은 파티션에 기록되어, 해당 장비 이벤트의 **처리 순서를 엄격하게 보장**합니다. | **[선행 조건]** 이벤트의 시간적 선후 관계가 유지되어, 재처리 시 데이터의 무결성 판단을 용이하게 합니다. |
| **처리 승인 (ACK)** | **Redis Streams (`XACK`)** | Worker가 메시지 처리를 완료하면, Redis Streams에 **`XACK`**을 보내 **완료를 확정**하고 메시지를 PEL에서 제거합니다. | **[체크포인트]** Worker 다운 시, **`XACK`되지 않은 메시지**만 PEL에 남아 불필요한 재처리를 방지합니다. |
| **Worker 장애 복구** | **Redis Streams (`XCLAIM`)** | Worker 다운 시, 재시작된 Worker는 PEL에 남은 메시지를 **`XCLAIM`**으로 인계받아 재처리합니다. | **[재처리 경로]** 장애 복구 과정은 필연적으로 **메시지 중복 재전송을 유도**하며, 이 중복 데이터는 다음 단계(DB)로 전달되어 **최종 멱등성 로직의 실행**을 강제합니다. |
| **중복 방지 (멱등성)** | **DB Unique Index** | JPA 저장 시 **`internalBarcodeId`** 컬럼에 **UNIQUE 인덱스**를 설정하여 DB 수준에서 **중복 저장을 원천 차단**합니다. | **[최종 보장]** 재전송된 메시지가 DB에 도달하더라도, DB의 **UNIQUE 제약 조건**이 두 번째 쿼리를 **실패(무시)**시키므로, 최종적으로 **데이터는 한 번만 저장됨**을 보장합니다. |

---

### 2. 최종 결론: 멱등성 보장 상호작용

이러한 상호작용을 통해 시스템은 **"최소 1회 처리(At-Least-Once)"**를 보장하면서도, 데이터베이스 저장 시점에서는 **"정확히 1회 처리(Exactly-Once 논리)"**를 달성하게 됩니다.

1.  **메시징 계층 (Redis Streams):** Worker 장애 시 미처리 메시지(`XCLAIM`)를 정확히 파악하여 중복 재전송을 유도합니다.
2.  **영속성 계층 (DB Unique Index):** 재전송된 메시지가 DB에 도달했을 때, `internalBarcodeId`를 기준으로 이미 존재하는 데이터는 무시하도록 하여, 최종적으로 데이터베이스에는 단 한 건의 레코드만 저장됨을 보장합니다.