# 🛡️ 물류 스캔 데이터 처리: 장애 복구 및 멱등성 보장 아키텍처

본 문서는 Kafka와 Redis Streams를 활용하여 **고성능 데이터 수집**을 달성하는 동시에, 시스템 장애 발생 시 **데이터의 무결성(Integrity)과 순서(Ordering)**를 보장하는 핵심 메커니즘을 설명합니다.

---

## 1. 🏗️ 아키텍처 개요

본 아키텍처는 Kafka와 Redis Streams를 중심으로 Ingest Worker가 **순서 보장** 및 **Exactly-Once 논리**를 적용하여 데이터를 DB에 안전하게 저장합니다.

| 구성 요소 | 역할 | 핵심 특성 |
| :--- | :--- | :--- |
| **Kafka (Inbound)** | 외부 시스템으로부터 대량의 스캔 원천 데이터를 **최초 수집 및 대기열 역할** | High Throughput, At-Least-Once |
| **Redis Streams** | Kafka에서 데이터를 가져와 **Worker 간 분배 및 ACK 관리 역할** | Low Latency, Consumer Group, XACK, XCLAIM |
| **Ingest Worker (Spring Boot)** | 데이터 처리 로직 및 DB 저장 담당 | Transactional, Idempotent (멱등성) |
| **MySQL (JPA)** | 영속성 및 최종 데이터 저장소 | ACID, 고유 인덱스 사용 |

---

## 2. 🔑 핵심 장애 복구 및 멱등성 보장 메커니즘

장애 복구 로직은 각 단계가 상호작용하여 최종적으로 데이터베이스에 단 하나의 레코드만 저장됨을 보장하는 **"Exactly-Once 논리"**를 달성하는 것이 목표입니다.

| 매커니즘 | 관련 시스템/설정 | 역할 및 동작 방식 | 상호작용을 통한 멱등성 보장 원리 |
| :--- | :--- | :--- | :--- |
| **2.1. 순서 보장** | **Kafka Producer Key (`deviceId`)** | Producer는 **`deviceId`를 메시지 Key**로 사용합니다. 동일 장비의 이벤트는 항상 같은 파티션에 기록되어, 해당 장비 이벤트의 **처리 순서를 엄격하게 보장**합니다. | **[선행 조건]** 이벤트의 시간적 선후 관계가 유지되어, 재처리 시 데이터의 무결성 판단을 용이하게 합니다. |
| **2.2. 처리 승인 (ACK)** | **Redis Streams (`XACK`)** | Worker가 메시지 처리를 완료하면, Redis Streams에 **`XACK`**을 보내 **완료를 확정**하고 메시지를 PEL에서 제거합니다. | **[체크포인트]** Worker 다운 시, **`XACK`되지 않은 메시지**만 PEL에 남아 불필요한 재처리를 방지합니다. |
| **2.3. Worker 장애 복구** | **Redis Streams (`XCLAIM`)** | Worker 다운 시, 재시작된 Worker는 PEL에 남은 메시지를 **`XCLAIM`**으로 인계받아 재처리합니다. | **[재처리 경로]** 장애 복구 과정은 필연적으로 **메시지 중복 재전송을 유도**하며, 이 중복 데이터는 다음 단계(DB)로 전달되어 **최종 멱등성 로직의 실행**을 강제합니다. |
| **2.4. 중복 방지 (멱등성)** | **DB Unique Index** | JPA 저장 시 **`internalBarcodeId`** 컬럼에 **UNIQUE 인덱스**를 설정하여 DB 수준에서 **중복 저장을 원천 차단**합니다. | **[최종 보장]** 재전송된 메시지가 DB에 도달하더라도, DB의 **UNIQUE 제약 조건**이 두 번째 쿼리를 **실패(무시)**시키므로, 최종적으로 **데이터는 한 번만 저장됨**을 보장합니다. |

---

## 3. 📝 최종 결론: 멱등성 보장 상호작용

이러한 상호작용을 통해 시스템은 **"최소 1회 처리(At-Least-Once)"**를 보장하면서도, 데이터베이스 저장 시점에서는 **"정확히 1회 처리(Exactly-Once 논리)"**를 달성하게 됩니다.

* **메시징 계층 (Redis Streams):** Worker 장애 시 미처리 메시지(`XCLAIM`)를 정확히 파악하여 중복 재전송을 유도합니다.
* **영속성 계층 (DB Unique Index):** 재전송된 메시지가 DB에 도달했을 때, `internalBarcodeId`를 기준으로 이미 존재하는 데이터는 무시하도록 하여, 최종적으로 데이터베이스에는 단 한 건의 레코드만 저장됨을 보장합니다.

---

## 4. ⚠️ 장애 시나리오 및 복구 분석

각 서비스의 일시적인 다운(2~3시간 이내) 및 복구 상황에 대한 복구 메커니즘 동작 분석입니다.

| 시나리오 | 발생 장애 | 복구 메커니즘 동작 | 복구 가능성 |
| :--- | :--- | :--- | :--- |
| **4.1. Ingest Worker 다운** | Worker가 처리 도중 다운되어 **`XACK`을 보내지 못한** 메시지 발생. | **재시작 후 `XCLAIM`:** Worker 재시작 시, 미처리 메시지를 인계받아 재처리하고, DB의 **UNIQUE 인덱스**가 중복 삽입을 차단합니다. | **완벽하게 복구** ✅ |
| **4.2. MySQL 데이터베이스 다운** | `repository.save()` 호출이 실패하고 **트랜잭션이 실패**합니다. | **DB 복구 후 `XCLAIM`:** `XACK`이 없었으므로 메시지는 Redis에 보존되며, DB 복구 후 Worker가 메시지를 `XCLAIM`으로 인계받아 **재저장**합니다. | **완벽하게 복구** ✅ |
| **4.3. Redis Streams 다운** | Worker가 Streams 접근에 실패하고 **대기 상태**에 빠집니다. | **복구 후 재개:** Redis 복구 시점까지 Worker는 대기하며, 복구 후 중단된 지점부터 **자동으로 처리를 재개**합니다. | **완벽하게 복구** ✅ |
| **4.4. Kafka 다운** | 외부 시스템이 전송을 못하거나 Worker가 가져오기를 중단합니다. | **시스템 대기:** Kafka 복구 후 메시지가 몰려도, Redis Streams로 순차적으로 전달되어 **순서 및 무결성**이 유지됩니다. | **완벽하게 복구** ✅ |